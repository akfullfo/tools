#!/usr/bin/env python
# ________________________________________________________________________
#
#  Copyright (C) 2015 Andrew Fullford
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# ________________________________________________________________________
#
 
import os, sys, time, re, socket, struct, urlparse, json, argparse, logging
from logging.handlers import SysLogHandler
import BaseHTTPServer
import xml.dom.minidom
from taskforce import utils
 
program = os.path.basename(os.path.splitext(sys.argv[0])[0])
logging_name = program

def_listen = '0.0.0.0:8080'
def_datadir = '/home/akfullfo/rainforest'
def_pidfile = program + '.pid'

def daemonize(**params):
	"""
This is a simple daemonization method.  It just does a double fork() and the
parent exits after closing a good clump of possibly open file descriptors.  The
child redirects stdin from /dev/null and sets a new process group and session.
If you need fancier, suggest you look at http://pypi.python.org/pypi/python-daemon/

Application logging setup needs to be delayed until after daemonize() is called.

Supported params:

	redir	- Redirect stdin, stdout, and stderr to /dev/null.  Default
		  is True, use "redir=False" to leave std files unchanged.

	log     - logging function, default is no logging.  A logging function
		  works best if you use stderr or a higher fd because these are
		  closed last.  But note that all fds are closed or associated
		  with /dev/null, so the log param is really only useful for
		  debugging this function itself.  A caller needing logging
		  should probably use syslog.
"""
	log = params.get('log')
	redir = params.get('redir', True)

	try:
		if os.fork() != 0:
			os._exit(0)
	except Exception as e:
		if log: log("First fork failed -- %s", str(e))
		return False
	try:
		os.setsid()
	except Exception as e:
		if log: log("Setsid() failed -- %s", str(e))

	try:
		if os.fork() != 0:
			os._exit(0)
	except Exception as e:
		if log: log("Second fork failed, pressing on -- %s", str(e))

	try:
		os.chdir('/')
	except Exception as e:
		if log: log("Chdir('/') failed -- %s", str(e))
	if redir:
		try: os.close(0)
		except Exception as e:
			if log: log("Stdin close failed -- %s", str(e))
		try:
			fd = os.open('/dev/null', os.O_RDONLY)
		except Exception as e:
			if log: log("Stdin open failed -- %s", str(e))
		if fd != 0:
			if log: log("Stdin open returned %d, should be 0", fd)
		try: os.close(1)
		except Exception as e:
			if log: log("Stdout close failed -- %s", str(e))
		try:
			fd = os.open('/dev/null', os.O_WRONLY)
		except Exception as e:
			if log: log("Stdout open failed -- %s", str(e))
		if fd != 1:
			if log: log("Stdout open returned %d, should be 1", fd)

	try:
		os.setpgrp()
	except Exception as e:
		if log: log("Setpgrp failed -- %s", str(e))

	if redir:
		try: os.close(2)
		except Exception as e:
			if log: log("Stderr close failed -- %s", str(e))
		try:
			fd = os.dup(1)
		except Exception as e:
			if log: log("Stderr dup failed -- %s", str(e))
		if fd != 2:
			if log: log("Stderr dup returned %d, should be 2", fd)
	for fd in range(3,50):
		try: os.close(fd)
		except: pass

def cidr2mask(addr):
	mask = long(0)
	addr = int(addr)
	if addr > 32 or addr < 0:
		return None
	while addr < 32:
		mask = (mask << 1) | 1
		addr += 1
	return ~mask & 0xFFFFFFFF

def ip2int(addr):
	try:
		return struct.unpack("!L", socket.inet_aton(addr))[0]
	except:
		return None

def iso8601(tim = time.time(), terse=False):
	frac = int((tim - int(tim)) * 1000.0 + 0.5)
	tim = int(tim)
	if frac >= 1000:
		#  Handle case where the fraction was >= 0.9995
		tim += 1
		frac = 0
	utc = time.gmtime(tim)
	if terse:
		fmt = "%Y%m%dT%H%M%S."
	else:
		fmt = "%Y-%m-%dT%H:%M:%S."
	return time.strftime(fmt, utc) + ('%03d' % (frac,)) + 'Z'

class Rainforest(object):

	#  File in datadir used to record current state
	#
	statefile_name = 'rainforest.state'

	#  Match valid hex numbers
	#
	is_hex = re.compile(r'^0x[0-9a-fA-F]+$')

	#  This is the number of seconds between Jan 1, 1970 UTC (unix epoch) and
	#  Jan 1, 2000 UTC (rainforest epoch).
	#
	#  Except the meter seems to actually be on local time, so subtract 6hrs
	#
	time_t_offset_2000 = 946706400 - 21600

	#  Configuration information for each message type.
	#
	config = {
		'InstantaneousDemand': {
			'event_name': 'demand',
			'desired_period': 30
		},
		'DeviceInfo': {
		},
		'NetworkInfo': {
		},
		'CurrentSummationDelivered': {
			'event_name': 'summation',
			'desired_period': 900
		},
		'PriceCluster': {
			#'event_name': 'price',
			#'desired_period': 60
		},
		'TimeCluster': {
		},
		'BlockPriceDetail': {
		}
	}

	#  Don't trigger a period update if the delta is less than this
	period_reset_tolerance = 5

	#  Response tuple when no action is needed
	#
	noop_response = ('', 'text/plain', 200)

	set_schedule_template = """
<RavenCommand>
	<Name>set_schedule</Name>
	<DeviceMacId>%s</DeviceMacId>
	<Event>%s</Event>
	<Frequency>0x%04x</Frequency>
	<Enabled>Y</Enabled>
</RavenCommand>
"""
	def __init__(self, **params):
		self.log = params.get('log')
		if not self.log:
			self.log = logging.getLogger(__name__)
			self.log.addHandler(logging.NullHandler())
		self.datadir = params.get('datadir')
		if self.datadir:
			if not os.access(self.datadir, os.W_OK | os.X_OK):
				#  Throw this early because we don't actually attempt
				#  access until a POST arrives.
				#
				raise Exception("Data directory '%s' is not writable" % (self.datadir))
			self.statefile = os.path.join(self.datadir, self.statefile_name)
			self.state = self.load_state()
			self.recording = True
		else:
			self.statfile = None
			self.state = {}
			self.recording = False

	def load_state(self):
		if not self.statefile:
			self.log.info("State file processing disabled")
			return {}
		try:
			with open(self.statefile, 'r') as f:
				prev_state = f.read()
		except Exception as e:
			self.log.warning("No previous state file '%s' -- %s", self.statefile, str(e))
			return {}
		try:
			return json.loads(prev_state)
		except Exception as e:
			self.log.warning("Parse failed on previous state file '%s' -- %s", self.statefile, str(e))
			return {}

	def save_state(self):
		if not self.statefile:
			self.log.debug("State file processing disabled")
			return
		temp = self.statefile + '.tmp'
		try:
			with open(temp, 'w') as f:
				f.write(json.dumps(self.state, indent=4))
		except Exception as e:
			self.log.error("Write failed to '%s' -- %s", temp, str(e))
			return
		try:
			os.rename(temp, self.statefile)
		except Exception as e:
			self.log.error("Rename of '%s' to '%s' failed -- %s", temp, self.statefile, str(e))

	def log_command(self, info, level=logging.DEBUG):
		self.log.log(level, "%s ...", info['_name'])
		for line in json.dumps(info, indent=4).splitlines():
			self.log.log(level, "    %s", line)

	def check_schedule(self, info):
		name = info['_name']
		config = self.config.get(name)
		dev_mac = info['_raw']['DeviceMacId']
		if not config:
			self.log.debug("No config for '%s', skipping schedule check", name)
			return self.noop_response
		desired_period = config.get('desired_period')
		if not desired_period:
			self.log.warning("No desired period for '%s', skipping schedule check", name)
			return self.noop_response
		event_name = config.get('event_name')
		if not event_name:
			self.log.warning("No event name for '%s', skipping schedule check", name)
			return self.noop_response
		prev_info = self.state.get(name)
		curr_ts = info['_timestamp']
		if prev_info and '_timestamp' in prev_info and prev_info['_timestamp']:
			prev_ts = prev_info['_timestamp']
		else:
			self.log.info("No previous timestamp for '%s', skipping schedule check", name)
			return self.noop_response
		delta = curr_ts - prev_ts
		if abs(delta - desired_period) < self.period_reset_tolerance:
			self.log.debug("Report delta %.1fs within tolerance for '%s', skipping schedule change", delta, event_name)
			return self.noop_response
		self.log.info("Delta of %.1fs for %s differs from desired %.0f, changing schedule",
							delta, event_name, desired_period)
		content = self.set_schedule_template % (dev_mac, event_name, desired_period)
		for line in content.splitlines():
			self.log.debug("%s", line.rstrip())
		return (content, 'text/xml', 200)

	def read_meter(self, item, info):
		name = info['_name']
		sys_timestamp = info['_timestamp']

		timestamp = info.get('TimeStamp')
		value = info.get(item)
		multiplier = info.get('Multiplier')
		divisor = info.get('Divisor')
		if value is None:
			raise Exception("Missing '%s' in %s" % (item, name,))
		if multiplier is None:
			raise Exception("Missing 'Multiplier' in %s" % (name,))
		if divisor is None:
			raise Exception("Missing 'Divisor' in %s" % (name,))
		result = float(value) * multiplier / divisor
		try:
			clock_delta = ', clock delta %.3fs' % (sys_timestamp - timestamp - self.time_t_offset_2000, )
		except Exception as e:
			self.log.warning("Could not convert TimeStamp %s to clock delta -- %s", repr(timestamp), str(e))
			clock_delta = ''
		self.log.debug("Result is %.3f kW%s", result, clock_delta)

		return result

	def record_data(self, tag, ts, value):
		if not self.datadir:
			return
		iso_ts = iso8601(ts)
		iso_date = iso_ts[:10]
		log.debug("%s: %.3f", tag, value)
		fname = os.path.join(self.datadir, iso_date + '.' + tag)

		with open(fname, 'a') as f:
			f.write("%s\t%.3f\n" % (iso_ts, value))

	def process(self, payload):
		try:
			dom = xml.dom.minidom.parseString(payload)
		except Exception as e:
			self.log.error("Payload parse failed -- %s", str(e), exc_info=True)
			self.log.error("Failed payload was ...")
			if len(payload) > 1000:
				payload = payload[:1000] + ' ...'
			for line in str(payload).splitlines():
				self.log.error("  ] %s", line)
			return
		self.log.debug("Payload parsed successfully ...")
		for line in dom.toprettyxml(indent="  ").splitlines():
			line = line.rstrip()
			if line:
				self.log.debug("  ] %s", line)

		resp = ('', 'text/plain', 200)

		for node in dom.getElementsByTagName('rainforest'):
			now = time.time()
			header = {}
			header['_version'] = node.getAttribute('version')
			header['_mac'] = node.getAttribute('macId')
			eagle_timestamp = node.getAttribute('timestamp')
			if eagle_timestamp:
				try:
					header['_timestamp'] = int(eagle_timestamp.strip('s'))
					log.debug("Eagle %s v%s timestamp delta %.3f",
							header['_mac'], header['_version'], now - header['_timestamp'])
				except Exception as e:
					self.log.warning("Could not load Eagle timestamp '%s' -- %s", eagle_timestamp, str(e))
					header['_timestamp'] = None
			else:
				self.log.warning("No timestamp in rainforest POST xml")

			if node.nodeType == node.ELEMENT_NODE and node.hasChildNodes():
				for command in node.childNodes:
					if command.nodeType != command.ELEMENT_NODE:
						continue
					if hasattr(self, command.nodeName) and callable(getattr(self, command.nodeName)):
						self.log.debug("%s has command element '%s'", node.nodeName, command.nodeName)
						info = {}
						raw_info = {}
						for elem in command.childNodes:
							if elem.nodeType != elem.ELEMENT_NODE:
								continue
							tag = elem.nodeName
							val = elem.childNodes[0].nodeValue.strip()
							valstr = val
							if self.is_hex.match(val):
								try:
									val = int(val, 0)
									if val > 0x7FFFFFFF:
										val -= 0x100000000
								except:
									pass
							self.log.debug("%s %s = %s", command.nodeName, elem.nodeName, repr(val))
							info[tag] = val
							raw_info[tag] = valstr
						info['_name'] = command.nodeName
						info['_raw'] = raw_info
						info['_timestamp'] = now

						#  Run the per-message processing
						#
						getattr(self, command.nodeName)(info)

						resp = self.check_schedule(info)

						self.state[command.nodeName] = info

					else:
						self.log.info("%s has unknown element '%s'", node.nodeName, command.nodeName)
			self.state['_timestamp'] = header['_timestamp']
			for tag in ['_mac', '_version']:
				if header[tag] != self.state.get(tag):
					self.log.info("Eagle %s value changed from %s to %s",
										tag, repr(self.state.get(tag)), header[tag])
					self.state[tag] = header[tag]
			self.save_state()
			return resp

	def InstantaneousDemand(self, info):
		self.log_command(info)
		self.record_data('demand', info['_timestamp'], self.read_meter('Demand', info))

	def DeviceInfo(self, info):
		self.log_command(info)

	def NetworkInfo(self, info):
		self.log_command(info)

	def PriceCluster(self, info):
		self.log_command(info)

	def CurrentSummationDelivered(self, info):
		self.log_command(info)
		self.record_data('summation', info['_timestamp'], self.read_meter('SummationDelivered', info))

	def TimeCluster(self, info):
		self.log_command(info)

	def BlockPriceDetail(self, info):
		self.log_command(info, level=logging.INFO)

class Hook(BaseHTTPServer.BaseHTTPRequestHandler):
	server_version = "eagle_hook/1.0"
	sys_version = ''

	def format_addr(self, addr, showport=False):
		if type(addr) is tuple and len(addr) == 2:
			if showport:
				return "%s:%d" % (addr[0], addr[1])
			else:
				return str(addr[0])
		elif type(addr) is str:
			return addr
		else:
			return str(addr)

	def log_message(self, fmt, *fargs):
		try:
			msg = fmt.strip() % fargs
		except Exception as e:
			msg = "Error formatting '%s' -- %s" % (str(fmt), str(e))
		try:
			saddr = self.format_addr(self.server.server_address, showport=True)
		except:
			saddr = 'unknown'
		try:
			raddr = self.format_addr(self.client_address)
		except:
			raddr = 'unknown'
		log.debug("%s>%s %s", raddr, saddr, msg)

	def send_resp(self, content, content_type='text/plain', code=200):
		self.send_response(code)
		self.send_header('Content-Length', str(len(content)))
		self.send_header('Content-Type', content_type)
		self.end_headers()
		self.wfile.write(content)

	def check_address(self):
		"""
		Verify that the peer is in the allowed networks.
	"""
		client_addr = ip2int(self.client_address[0])
		if authorized_addrs is None:
			return True
		for addr, mask in authorized_addrs:
			if (addr & mask) == (client_addr & mask):
				return True
		log.warning("Silently rejecting connection -- unauthorized address from %s", self.format_addr(self.client_address))
		return False
		
	def do_GET(self):
		if self.check_address():
			log.warning("Ignoring GET from %s", self.client_address[0])
		self.send_resp('Ok\r\n')
 
	def do_POST(self):
		global eagle
		if not self.check_address():
			log.warning("Ignoring GET from %s", self.client_address[0])
			self.send_resp('Ok\r\n')

		length = int(self.headers['Content-Length'])
		log.debug("Got %d bytes", length)
	 
		try:
			content, content_type, code = eagle.process(self.rfile.read(length).decode('utf-8'))
		except Exception as e:
			log.error("Processing failed -- %s", str(e), exc_info=True)
			self.send_resp('Bad data\r\n', code=400)
		else:
			self.send_resp(content, code=code, content_type=content_type)
 
p = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
	description="Track demand power from Eagle Rainforest device.")

p.add_argument('-V', '--version', action='store_true', dest='version', help='Report version of package and exit.')
p.add_argument('-v', '--verbose', action='store_true', dest='verbose', help='Verbose logging for debugging.')
p.add_argument('-q', '--quiet', action='store_true', dest='quiet', help='Quiet logging, warnings and errors only.')
p.add_argument('-e', '--log-stderr', action='store_true', dest='log_stderr', help='Log to stderr instead of syslog.')
p.add_argument('-b', '--background', action='store_true', dest='daemonize', help='Run in the background.')
p.add_argument('-d', '--data-dir', action='store', dest='datadir', metavar='DIR', default=def_datadir,
			help='Directory to record state and history, default: ' + def_datadir)
p.add_argument('-p', '--pidfile', action='store', dest='pidfile', metavar='FILE',
			help='Pidfile path, default "%s", "-" means none.' %(os.path.join(def_datadir, def_pidfile),))
p.add_argument('-a', '--authaddr', action='append', dest='authaddrs', metavar='NET',
			help='Only allow contact from these addresses.  May be used multiple times.  Default is to allow all.')
p.add_argument('-l', '--listen', dest='listen', metavar='[address:]port', default=def_listen,
			help='Listent address, default: ' + def_listen)

args = p.parse_args()

if args.version:
	print(Hook.server_version)
	sys.exit(0)

pidfile = None
if args.pidfile is None and args.daemonize:
	if args.datadir:
		pidfile = os.path.join(args.datadir, def_pidfile)
else:
	pidfile = args.pidfile
if pidfile == '' or pidfile == '-':
	pidfile = None

if pidfile:
	pidfile = os.path.realpath(pidfile)

authorized_addrs = None
if args.authaddrs:
	authorized_addrs = []
	for addr in args.authaddrs:
		f = addr.split('/', 1)
		ip = f[0]
		if len(f) > 1:
			cidr = f[1]
		else:
			cidr = 32
		authorized_addrs.append((ip2int(ip), cidr2mask(cidr)))

if args.daemonize:
	daemonize()

if args.log_stderr:
	log_handler = logging.StreamHandler()
	log_formatter = logging.Formatter(fmt="%(asctime)s %(levelname)s %(message)s")
else:
	logparams = {}
	for addr in ['/dev/log', '/var/run/log']:
		if os.path.exists(addr):
			logparams['address'] = addr
			break
	log_handler = SysLogHandler(**logparams)
	log_formatter = logging.Formatter(fmt="%(name)s[%(process)d]: %(levelname)s %(message).1000s")

log = logging.getLogger(logging_name)
log_handler.setFormatter(log_formatter)
log.addHandler(log_handler)

if args.verbose:
	log.setLevel(logging.DEBUG)
elif args.quiet:
	log.setLevel(logging.WARNING)
else:
	log.setLevel(logging.INFO)

def_address, def_portstr = def_listen.split(':')

address = None
if args.listen.find(':') >= 0:
	address, portstr = args.listen.split(':')
else:
	portstr = args.listen
if not address:
	address = def_address
if not portstr:
	portstr = def_portstr
port = int(portstr)

log.info("%s listening on %s:%d", Hook.server_version, address, port)

if pidfile is not None:
	try:
		utils.pidclaim(pidfile)
	except Exception as e:
		log.critical('Fatal error -- %s', str(e), exc_info=args.verbose)
		sys.exit(2)

eagle = Rainforest(log=log, datadir=args.datadir)

server_class = BaseHTTPServer.HTTPServer
httpd = server_class((address, port), Hook)
code = 0
try:
	httpd.serve_forever()
except KeyboardInterrupt:
	log.info("Exiting on interrupt")
except Exception as e:
	log.error("Exiting on exception -- %s", str(e), exc_info=True)
	code = 2

try:
	httpd.server_close()
except Exception as e:
	log.warning("Exception while attempting to close server -- %s", str(e))
	if not code:
		code = 1

sys.exit(code)
