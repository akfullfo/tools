#!/usr/bin/env python
# ________________________________________________________________________
#
#  Copyright (C) 2020 Andrew Fullford
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# ________________________________________________________________________
#

import sys
import os.path
import argparse
import subprocess

DEF_HOSTS = ['boinc-00', 'boinc-01', 'boinc-02', 'boinc-03']

DEF_TIMEOUT = 10

TRANSITIONS = {
        0: 'active',
        1: 'inactive',
    }

CMD_STATUS = 'systemctl is-active boinc-client'
CMD_STOP = 'systemctl stop boinc-client'
CMD_START = 'systemctl start boinc-client'

#  Check mode is:  systemctl is-active boinc-client
#  Answers: <= 0 should be "active"
#           >= 1 should be "inactive"


def parse_args(argv):
    p = argparse.ArgumentParser(
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description="""
    Issue remote controls to boinc servers.

    The boinc-client is started on transitions to cost level 0
    and stopped on transitions from cost level 0.
    """
    )
    p.add_argument('-H', '--host', action='append', metavar='addr',
                    help="Remote boinc host, default: %s" % ' '.join(DEF_HOSTS))
    p.add_argument('-t', '--timeout', action='store', type=int, default=DEF_TIMEOUT, metavar='secs',
                    help="Connect timeout for ssh, default %r" % DEF_TIMEOUT)
    p.add_argument('prev_level', type=int, help="The previous cost level")
    p.add_argument('next_level', type=int, help="The next cost level")

    args = p.parse_args()
    if args.host is None:
        args.host = DEF_HOSTS
    return args


def main(argv=None):
    args = parse_args(argv)

    expected = TRANSITIONS.get(args.next_level)
    is_check = args.prev_level == args.next_level

    keyfile = os.path.join(os.path.dirname(os.path.dirname(sys.argv[0])), '.ssh', 'id_rsa')

    ssh_args = ['ssh',
                    '-2',
                    '-T',
                    '-x',
                    '-o', 'PreferredAuthentications=publickey',
                    '-o', 'ConnectTimeout=%d' % args.timeout,
                ]
    if os.path.isfile(keyfile):
        ssh_args += ['-i', keyfile]

    for host in args.host:
        cmd = ssh_args + [host, CMD_STATUS]
        try:
            status = subprocess.check_output(cmd, stderr=subprocess.STDOUT, universal_newlines=True).strip()
        except subprocess.CalledProcessError as e:
            status = e.output.strip()
            if status != 'inactive':
                sys.stderr.write("%s status check failed -- %s\n" % (host, status if status else e))
                continue
        except Exception as e:
            sys.stderr.write("%s status check failed -- %s\n" % (host, e))
            continue
        if status != expected:
            if is_check:
                sys.stderr.write("%s found %s when %s expected, attempting correction\n" % (host, status, expected))
            try:
                cmd = ssh_args + [host, CMD_STOP if expected == 'inactive' else CMD_START]
                subprocess.check_output(cmd, stderr=subprocess.STDOUT, universal_newlines=True).strip()
                sys.stderr.write("%s changed from %s to %s\n" % (host, status, expected))
            except Exception as e:
                sys.stderr.write("%s update failed -- %s\n" % (host, e))
    return 0


exit(main())
